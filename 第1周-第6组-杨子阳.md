## 第0天
　　这一天的内容主要是作者对于写书动机、如何开发操作系统以及接下来30天要做的内容的介绍，作者的风格是大致讲解基础概念，直接上手开发，先做出demo来，然后逐步添加功能，在开发中理解概念，从错误中学习经验。
## 第1天
- 使用BZ（二进制编辑器）制作软盘映像文件，一开始跟着作者在BZ里输入代码，结果发现书里的代码不全。所以，只能直接从光盘内容里复制粘贴。在cmd界面，输入“run”指令，“操作系统”会在QEMU中运行，可以看到如下界面


<div align=center><img src="image\helloos0.png" height="340" width="500">
<div align=left>

- 作者开发了一个汇编语言编译器“nask”，通过汇编重写上节的代码，再进行加工润色，加上注释等。通过nask.exe将nas文件转化为img文件，即可通过上节的方法启动操作系统。

> 一些缩写及解释
DB: define byte
DW: define word
DD: define double-word
RESB: reserve byte
$: 当前行的字节数

## 第2天
- 对汇编代码的功能解释，即调用显卡在屏幕上输出字符。

> 汇编指令
  ORG origin 指定程序的装载地址
  JMP jump 跳转
  “entry:” 标号，代表地址
  MOV move 传送字或字节
  ADD add 加法
  CMP compare 比较
  JE jump if equal 等于转移
  INT interrupt 中断  利用INT可以调用BIOS中的函数
  HLT halt CPU睡眠

> 寄存器称及作用解释
  AX: accumulator 累加寄存器
  CX: counter 计数寄存器
  DX: data  数据寄存器
  BX: base 基址寄存器
  SP: stack pointer 栈指针寄存器
  BP: base pointer 基址指针寄存器
  SI: source index 源变址寄存器
  DI: destination index 目的变址寄存器
  AL: accumulator low 累加寄存器低位
  CL: counter low 计数寄存器低位
  DL: data low 数据寄存器低位
  BL: base low 基址寄存器低位
  AH: accumulator high 累加寄存器高位
  CH: counter high 计数寄存器高位
  DH: data high 数据寄存器高位
  BH: base high 基址寄存器高位
  EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI分别是是AX, CX, DX, BX, SP, BP, SI, DI的扩展，低16位即为对应寄存器
  ES: extra segment 附加段寄存器
  CS: code segment 代码段寄存器
  SS: stack segment 栈段寄存器
  DS: data segment 数据段寄存器
  FS: segment part 2 没有名称 （extra segment 附加段寄存器）
  GS: segment part 3 没有名称 （extra segment 附加段寄存器）

  - 版本变为helloos04，利用原有代码删除启动区以外部分，制作512字节的启动区ipl。利用磁盘映像管理工具eding.exe在空白的磁盘映像文件写入ipl.bin的内容。
  - 版本进入helloos05，利用Makefile替代批处理文件，Makefile比批处理文件更加智能，它能根据情况判断需要执行的指令，避免了每次需要重新生成已有的文件。这样内容得到了精简，功能反而更强大了，不过遗憾的是作者对Makefile和make.bat中的一些命令并未加以解释。

  ## 第3天
  - 由于操作系统过于简陋，名称被作者改为“harrib”(纸娃娃)，然后添加了汇编语言编写的读盘程序。将从软盘读取的数据填满了内存0x08200 ~ 0x34fff的地方，至此启动区的制作完成。

  > 新增汇编指令
    JC: jump if carry 有进位转移
    JNC: jump if not carry 无进位转移
    JAE: jump if above or equal 大于等于时转移
    JBE: jump if below or equal 小于等于时转移
    JB: jump if below 小于时转移
    EQU: equal 类似于C语言的#define
    RET: return 返回

  - 作者写了以一个非常简短的“操作系统”只有以下三行代码

  ```
  fin:
      HLT
      JMP fin
  ```

  用nask编译生成haribote.sys，然后利用edimg将其保存到磁盘映像里。使用BZ查看haribote.sys和haribote.img,可以发现
  >
    1. 文件名会写在0x002600以后的地方
    2. 文件的内容会写在0x004200以后的地方

  - 在进行到harib00g的时候发现错误，由于之前编写读取磁盘的代码时未将`JNC fin`改为`JNC next`，故运行时并不会出现全黑画面，经过与作者代码对比改正。

  - 切换到32位模式就无法调用BIOS功能，所以切换之前，需要修改haribote.nas,记录画面模式，取得键盘信息。
  - 切换到32位模式，开始使用C语言进行编程。为了实现C语言程序调用，作者在haribote.nas中添加了100行左右的汇编代码同时将其改名为asmhead.nas，不过由于程序很复杂作者会在后面的内容中在对其进行讲解。下面是作者在第三天编写的bootpack.c

  ```cpp
  void io_hlt(void);
  void HariMain(void)
  {

  fin:
        io_hlt();
  	  goto fin;

  }

  ```

  > 由bootpack生成机器语言的过程
    1. 使用cc1.exe从bootpack.c生成bootpack.gas。
    2. 使用gas2nask.exe从bootpack.gas生成bootpack.nas。
    3. 使用nask.exe从bootpack.nas生成bootpack.obj。
    4. 使用obi2bim.exe从bootpack.obj生成bootpack.bim。
    5. 使用bim2hrb.exe从bootpack.bim生成bootpack.hrb。
    6. 这样就做成了机器语言，再使用copy指令将asmhead.bin与bootpack.hrb单纯结合到起来，就成了haribote.sys。

- 为了让计算机处于HALT状态，作者用汇编语言写了io_hlt函数。至此，第三天结束。
