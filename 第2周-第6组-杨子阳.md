## 第四天
- 向naskfun.nas中添加write_mem8函数，使得能够在C语言中使用此函数来向内存中的指定地址写入数据。在与C语言联合使用时，只有`EAX`,`ECX`,`EDX`三个寄存器可以自由使用。通过向VRAM中写入数据，可以显示出条纹图案来。这段代码中还增加了`INSTRSET`指令，是用来告诉nask这个程序是给486使用的。
- 下一节里，作者讲解了C语言中指针的多种用法来取代write_mem函数。
>
  char *p  用于BYTE类地址
  short *p 用于WORD类地址
  int *p   用于DWORD类地址

- 以下三种写法等价
```c
for (i = 0xa0000; i <= 0xaffff; i++) {
      p = (char *)i;
      *p = i & 0x0f;
}
```
```c
p = (char *) 0xa0000;
for (i = 0; i <= 0xaffff; i++) {
      *(p + i) = i & 0x0f;
}
```
```c
p = (char *) 0xa0000;
for (i = 0; i <= 0xffff; i++) {
      p[i] = i & 0x0f;
}
```
**小Tips**：加法运算可以交换顺序，于是(p+i)和(i+p)，p[i]和i[p]，a[2]和2[a]都是一个意思，这更能说明它们与数组没有关系。
- 在给颜色编号时，作者使用加了static的数组声明来节省赋值语句花费的空间
**情况一**
```c
char a[3];
a[0] = 1;
a[1] = 2;
a[2] = 3;
```
翻译成汇编如下：
```x86asm
a:
    RESB 3
    之后是赋值语句
```
**情况二**
```c
static char a[3] = {0x01, 0x02, 0x03};
```
翻译成汇编如下:
```x86asm
a:
    DB 0x01, 0x02, 0x03
```

- io_out8函数可向设备中发送信号，使用此函数设定调色板。设定调色板时，需要先屏蔽中断，再恢复中断。
> CLI clear interrupt 清中断允许位
  STI set interrupt 置中断允许位

- 此处介绍了`EFLAGS`寄存器
![](image\eflags.png)
利用io_load_eflags函数保存eflags的值, 处理结束后再调用io_store_eflags恢复。不过CPU中没有`MOV EAX, EFLAGS`之类的指令，能够用来读写EFLAGS的只有 **PUSHFD（push flags double-word，将标志位的值按双字压入栈）** 和 **POPFD(pop flags double-word，按双字长将标志位从栈弹出)**指令。因此以上两个函数的汇编代码是这样的
```x86asm
_io_load_eflags:        ; int io_load_eflags(void);
        PUSHFD          ; 指PUSH EFLAGS
        POP     EAX
        RET
_io_store_eflags:       ; void io_store_eflags(int eflags);
        MOV     EAX, [ESP+4]
        PUSH    EAX
        POPFD           ; 指POP EFLAGS
        RET
```
**注意**：io_load_eflags的返回值从何得到？根据C语言的规约，执行RET时，EAX中的值就是返回值。

- 像素坐标(x,y)对应的VRAM地址按下式计算
  `0xa0000 + x + y * 320`
  根据上式我们可以在窗口320x200个像素中随意填充啦，用画矩形的函数得到的效果是这样的
  ![](image\rectangle.png)
  最终的界面如下
  ![](image\final.png)

## 第五天
- 从asmhead.nas中取vram等信息，将其放到一个结构体中
```c
struct BOOTINFO {
	char cyls, leds, vmode, reserve;
	short scrnx, scrny;
	char *vram;
};
```
将显示画面背景的部分独立出来，单独做成一个函数init_screen。
- 导入字体数据hankaku.txt,然后用makefont.exe将此文本输出成16x256=4096字节的文件。编译后生成hankaku.bin文件，加上连接所必须的接口信息变成目标文件（由bin2obj.exe来完成），相当于以下汇编语言
```x86asm
_hankaku:
    DB 各种数据（共4096字节）
```
这些操作需要在MAKEFILE中增加代码
在C语言中使用字体时，需要写上`extern char hankaku[4096];`，像这样在源程序之外的数据都需要加上`extern`。
> OSASK 的 字 体 数 据 ， 依 照 一 般 的 ASCⅡ 字 符 编 码 ， 含 有 256 个 字 符 。 A 的 字 符 编 码 是 0x41, 所以 A 的 字 体 数 据 ， 放 在 “hankaku + 0x41 * 16 ” 开 始 的 16 字 节 里 。 C 语 言 中 A 的 字 符 编 码 可 以 用 ’ A’ 来 表 示 ， 正 好 可 以 用 它 来 代 替 0x41 ， 所 以 也 可 以 写 成 “hankaku+’A’* 16 ” 。

显示如下
![](image\ABC123.png)
- C语言中字符串都是以0x00结尾的，所以我们可以方便的编写一个显示字符串的函数
```c
void putfonts8_asc(char *vram, int xsize, int x, int y, char c, unsigned char *s)
{
	extern char hankaku[4096];
	for(; *s != 0x00; s++) {
		putfont8(vram, xsize, x, y, c, hankaku + *s * 16);
		x += 8;
	}
	return;
}
```
- 使用`sprintf`函数输出变量的值，`sprintf`和`printf`最大的区别是在于它不是按指定格式输出，只是将输出内容作为字符串写在内存中，它在制作者的精心设计下能够不使用操作系统的任何功能，使用时需要在程序开头写上`#include<stdio.h>`，格式类似printf
![](image\format.png)
- 现实鼠标指针的方法，类似于显示字符。
- 为了让CPU动起来，我们需要GDT 和 IDT的初始化。它们都是有关CPU的设定，为了让操作系统能够使用32位模式，需要对CPU进行各种设定。
> GDT global (segment) descriptor table 全局段号记录表
  GDTR global (segment) descriptor table register 全局段号记录表寄存器
  IDT interrupt descriptor table  中断记录表
- 因为段寄存器是16位，所以可以处理0~65535范围的数，但由于CPU设计上的问题，段寄存器的低3位不能使用。故可以定义8192个段，设定这些段需要8192x8=65536字节。这64KB被写入内存中，称为GDT，然后将内存的起始地址和有效设定个数放在CPU内被称作GDTR的特殊寄存器中，设定就完成了。使用鼠标需要中断机制，为了实现中断机制，必须设定IDT，其记录了0~255的终端号码与函数调用的关系，设定方法与GDT很相似。

## 第六天
- 首先分割源文件，整理Makefile，整理头文件。
- 对第五天中naskfunc.nas新增函数的解释
```x86asm
_load_gdtr:		; void load_gdtr(int limit, int addr);
		MOV		AX,[ESP+4]		; limit
		MOV		[ESP+6],AX
		LGDT 	[ESP+6]
		RET
```
这个函数用来将指定的段上限和地址赋值给名为GDTR的48位寄存器，其并不能用MOV来赋值，只能给它指定一个内存地址，让它从指定的地址读取6个字节，然后赋值给GDTR寄存器。
> 该寄存器的低16位（即内存的最初2个字节）是段上限，它等于“GDT的有效字节数 - 1”。剩下的高32位（即剩余的4个字节），代表GDT的开始地址。在最初执行这个函数的时候，DWORD[ESP + 4]里存放的是段上限，DWORD[ESP+8]里存放的是地址。具体到实际的数值，就是0x0000ffff和0x00270000。把它们按字节写出来的话，就成了[FF FF 00 00 00 00 27 00]（要注意低位放在内存地址小的字节里 ）。为了执行LGDT，笔者希望把它们排列成[FF FF 00 00 27 00]的样子，所以就先用“MOV AX,[ESP + 4]”读取最初的0xffff，然后再写到[ESP + 6]里。这样，结果就成了[FF FF FF FF 00 00 27 00]，如果从[ESP + 6]开始读6字节的话，正好是我们想要的结果。

  dsctbl.c里的set_segmdesc函数
```c
struct SEGMENT_DESCRIPTOR {
short limit_low, base_low;
char base_mid, access_right;
char limit_high, base_high;
};
void set_segmdesc(struct SEGMENT_DESCRIPTOR *sd, unsigned int limit, int base, int ar)
{
if (limit > 0xfffff) {
ar |= 0x8000; /* G_bit = 1 */
limit /= 0x1000;
}
sd->limit_low = limit & 0xffff;
sd->base_low = base & 0xffff;
sd->base_mid = (base >> 16) & 0xff;
sd->access_right = ar & 0xff;
sd->limit_high = ((limit >> 16) & 0x0f) | ((ar >> 8) & 0xf0);
sd->base_high = (base >> 24) & 0xff;
return;
}
```
  这个函数是按照CPU的规格要求，将段的信息归结成8个字节写入内存。

  首先是段的地址。地址用32位表示，称为段的基址（base）。在这里分为low（2字节），mid（1字节）和high（1字节）3段，合起来32位，是为了与80286时代的程序兼容才分为三段。

  段上限最大4GB即32位，但只能使用20位，指定到1MB为止。为了扩大指定段的大小，段属性里设置了一个标位Gbit（G：granularity）。当这个标志位为1时，limit的单位不解释成字节（byte），而解释成页（page，4KB），这样4KBx1M=4GB。20位的段上限分别写到limit_low和limit_high里。

  段属性，又称为“段的访问控制权属性”，在程序中用变量名access_right或ar来表示。因为12位段属性中的高4位放在limit_high的高4位里，所以程序里有意把ar当做如下的16位构成来处理：
  `xxxx0000xxxxxxxx`(其中x是1或1)

  ar的高4位被称为“扩展访问权”，由“GD00”构成，G指G bit，D指段的模式，1时指32位模式，0是指16位模式，通常使用D=1的模式。

  低8位简单介绍
  > 00000000 （ 0x00 ） ：未使用的记录表（descriptor table ）。
    10010010 （ 0x92 ） ：系统专用，可读写的段。不可执行。
    10011010 （ 0x9a ） ：系统专用，可执行的段。可读不可写。
    11110010 （ 0xf2 ） ：应用程序用，可读写的段。不可执行。
    11111010 （ 0xfa ） ：应用程序用，可执行的段。可读不可写。

  CPU是处于系统模式还是应用模式，取决于执行中的应用程序是位于访问权位为0x9a的段，还是位于访问权位0xfa的段。

- 初始化PIC(programmable interrupt controller)。PIC是将8个中断信号集合成一个中断信号的装置，为了处理更多的中断信号增加了另一个PIC。与CPU直接相连的PIC称为主PIC（master PIC），与主PIC相连的PIC称为从PIC（slave PIC）。主PIC负责处理第0到第7号中断信号，从PIC负责处理第8到第15号中断信号。
![](image\pic.png)
```c
void init_pic(void)
/* PIC的初始化 */
{
io_out8(PIC0_IMR, 0xff ); /* 禁止所有中断 */
io_out8(PIC1_IMR, 0xff ); /* 禁止所有中断 */
io_out8(PIC0_ICW1, 0x11 ); /* 边沿触发模式（edge trigger mode） */
io_out8(PIC0_ICW2, 0x20 ); /* IRQ0-7由INT20-27接收 */
io_out8(PIC0_ICW3, 1 << 2); /* PIC1由IRQ2连接 */
io_out8(PIC0_ICW4, 0x01 ); /* 无缓冲区模式 */
io_out8(PIC1_ICW1, 0x11 ); /* 边沿触发模式（edge trigger mode） */
io_out8(PIC1_ICW2, 0x28 ); /* IRQ8-15由INT28-2f接收 */
io_out8(PIC1_ICW3, 2 ); /* PIC1由IRQ2连接 */
io_out8(PIC1_ICW4, 0x01 ); /* 无缓冲区模式 */
io_out8(PIC0_IMR, 0xfb ); /* 11111011 PIC1以外全部禁止 */
io_out8(PIC1_IMR, 0xff ); /* 11111111 禁止所有中断 */
return;
}
```
**IMR（interrupt mask register）**“是中断屏蔽寄存器”，8位对应8路信号，如果某一位是1则对应IRQ（interrupt request）信号被屏蔽。**ICW(initial control word)**是“初始化控制数据”，有4个。ICW1和ICW4与PIC主板配线方式、中断信号的电气特性有关，ICW3是有关主-从连接的设定，对主PIC而言，第几号IRQ与从PIC相连，是用8位来设定的，最多驱动8个从PIC，对从PIC而言，该从PIC与主PIC的第几号相连，用3位来设定。因此不同的操作系统可以进行独特设定的就只有ICW2了，它决定了IRQ以哪一号中断通知CPU，我们以INT 0x20~0x2f接收中断号IRQ0~15。INT 0x00~0x1f用于CPU内部自动产生的保护通知。
- 鼠标是IRQ12，键盘是IRQ1，所以编写了用于INT 0x2c和INT 0x21的中断处理程序。由于中断处理完成之后，还需要返回，即执行`IRETD（interrupt return DWORD）`指令，所以中断返回程序的正常运行还需要借助汇编语言。
```c
/*int.c的节选*/
void inthandler21(int *esp)
/* 来自PS/2键盘的中断 */
{
struct BOOTINFO *binfo = (struct BOOTINFO *) ADR_BOOTINFO;
boxfill8(binfo->vram, binfo->scrnx, COL8_000000, 0, 0, 32 * 8 - 1, 15);
putfonts8_asc(binfo->vram, binfo->scrnx, 0, 0, COL8_FFFFFF, "INT 21 (IRQ-1) : PS/2 keyboard");
for (;;) {
io_hlt();
}
}
```
```x86asm
; naskfunc.nas节选
EXTERN _inthandler21, _inthandler2c
_asm_inthandler21:
PUSH ES
PUSH DS
PUSHAD
MOV EAX,ESP
PUSH EAX
MOV AX,SS
MOV DS,AX
MOV ES,AX
CALL _inthandler21
POP EAX
POPAD
POP DS
POP ES
IRETD
```
其中`PUSHAD（push all data）`相当于
> PUSH EAX
PUSH ECX
PUSH EDX
PUSH EBX
PUSH ESP
PUSH EBP
PUSH ESI
PUSH EDI

`POPAD（pop all data）`相当于相反的操作
`CALL`是调用函数的指令
- 最后将asm_inthandler21注册到IDT中去
```c
/* IDT的设定 */
set_gatedesc(idt + 0x21, (int) asm_inthandler21, 2 * 8, AR_INTGATE32);
set_gatedesc(idt + 0x2c, (int) asm_inthandler2c, 2 * 8, AR_INTGATE32);
```
> asm_inthandler21注册在idt的第0x21号。这样，如果发生中断了，CPU就会自动调用asm_inthandler21。这里的2 * 8表示的是asm_inthandler21属于哪一个段，即段号是2，乘以8是因为低3位有着别的意思，这里低3位必须是0。
  ```c
  set_segmdesc(gdt + 2, LIMIT_BOTPAK, ADR_BOTPAK, AR_CODE32_ER);
  ```
  程序中的以上语句说明号码为2的段正好涵盖了整个bootpack.hrb.
  最后的AR_INTGATE32将IDT的属性，设定为0x008e。它表示这是用于中断处理的有效设定.

在HariMain的最后，修改了PIC的IMR，这样就能接受来自鼠标和键盘的中断了。
