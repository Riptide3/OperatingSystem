## 第七天
- 为了获取按键编码，需要设置缓冲区。按下或松开键盘时，会产生两个中断，分别发送两个按键码。一开始，由于只设置了一个字符的缓冲区。在程序处理第一个中断时，第二个按键码就被发送了，由于还未开中断，所以第二个中断产生的按键码被丢弃。再扩大缓冲区，同时使用FIFO队列后，可以记录大量的数据，执行速度也得到了提高。
- 由于鼠标只要一动就会产生中断，所以主板上虽然有鼠标用的电路，但只要不执行激活鼠标的指令，就不会产生鼠标的中断信号。想要使用鼠标，要想让鼠标控制电路有效，然后再让鼠标有效。事实上，鼠标控制电路包含在键盘控制电路里，如果键盘控制电路的初始化正常完成，鼠标控制电路的激活也就完成了。键盘控制电路没有CPU电路快，所以我们需要一个`wait_KBC_sendready`函数来确认是否可以往键盘控制电路传送信息。如果键盘控制电路可以接受CPU指令了，CPU从设备号码0x0064处所得的数据的倒数第二位应该是0。将模式设置为鼠标模式后，鼠标控制电路就准备完成，然后发送鼠标激活指令，待鼠标收到指令后，就会回复信息0xfa，这样鼠标中断就可以收到了。
- 鼠标数据的取得方法与键盘完全相同，要靠中断号码来区分数据来自键盘还是鼠标。由于鼠标往往会更快地送出大量数据，所以我们将它的FIFO缓冲区增加到128字节，编译运行后，可以显示出来自键盘和鼠标的数据。

    ![](image\mousedata.png)

## 第八天
- 鼠标移动每次会产生三个字节的数据，第八天一开始的工作是将鼠标的数据构建了一个结构体，然后整理了有关代码，将数据显示在屏幕上，如下图

    ![](image\mousedata1.png)
第一位会在0~3的范围内变化，第二位会在点击鼠标时发生变化，三四位与鼠标的左右移动有关，五六位与鼠标的上下移动有关。
- 然后向鼠标结构体中增加几个变量用于存放解读结果，x，y，btn，分别用于存放移动信息和鼠标按键状态。加上了对第一字节的判断，以防止鼠标出现接触不良等情况导致数据出问题。鼠标按键的状态，存放在buf[0]的低三位。x和y的第八位及以后位全部设成1或全部都保留为0，就能正确的解读x和y。鼠标与屏幕的y方向正好相反，对y进行取反操作。通过如下代码，鼠标就能移动了
    ```c
    } else if (fifo8_status(&mousefifo) != 0) {
        i = fifo8_get(&mousefifo);
        io_sti();
        if (mouse_decode(&mdec, i) != 0) {
        /* 数据的3个字节都齐了，显示出来 */
        sprintf(s, "[lcr %4d %4d]", mdec.x, mdec.y);
        if ((mdec.btn & 0x01) != 0) {
            s[1] = 'L';
        }
        if ((mdec.btn & 0x02) != 0) {
            s[3] = 'R';
        }
        if ((mdec.btn & 0x04) != 0) {
            s[2] = 'C';
        }
        boxfill8(binfo->vram, binfo->scrnx, COL8_008484, 32, 16, 32 + 15 * 8 - 1, 31);
        putfonts8_asc(binfo->vram, binfo->scrnx, 32, 16, COL8_FFFFFF, s);
        /* 鼠标指针的移动 */
        boxfill8(binfo->vram, binfo->scrnx, COL8_008484, mx, my, mx + 15, my + 15); /* 隐藏鼠标 */
        mx += mdec.x;
        my += mdec.y;
        if (mx < 0) {
            mx = 0;
        }
        if (my < 0) {
            my = 0;
        }
        if (mx > binfo->scrnx - 16) {
            mx = binfo->scrnx - 16;
        }
        if (my > binfo->scrny - 16) {
            my = binfo->scrny - 16;
        }
        sprintf(s, "(%3d, %3d)", mx, my);
        boxfill8(binfo->vram, binfo->scrnx, COL8_008484, 0, 0, 79, 15); /* 隐藏坐标 */
        putfonts8_asc(binfo->vram, binfo->scrnx, 0, 0, COL8_FFFFFF, s); /* 显示坐标 */
        putblock8_8(binfo->vram, binfo->scrnx, 16, 16, mx, my, mcursor, 16); /* 描画鼠标 */
        }
    }
    ```
    但这时还有一个小问题，由于没考虑到叠加处理，鼠标移动时，会将任务栏消除，这个问题会在后面解决。

    ![](image\mousemove.png)

- 作者终于要把前面挖的坑给填了，asmhead.nas中的代码，在此节中给出了解释。

```x86asm
; PIC关闭一切中断
;   根据AT兼容机的规格，如果要初始化PIC，
;   必须在CLI之前进行，否则有时会挂起，
;   随后进行PIC的初始化

        MOV     AL,0xff
        OUT     0x21,AL
        NOP                     ; 如果连续执行OUT指令，有些机种会无法正常运行
        OUT     0xa1,AL

        CLI                     ; 禁止CPU级别的中断
```

上面这段汇编代码功能相当于下面的C语言代码

```c
io_out8(PIC0_IMR,  0xff  ); /* 禁止主PIC的全部中断 */
io_out8(PIC1_IMR,  0xff  ); /* 禁止从PIC的全部中断 */
Io_cli(); /*禁止CPU级别的中断*/
```

为了让CPU能够访问1MB以上的内存空间，设定A20GATE

```x86asm
        CALL    waitkbdout
        MOV     AL,0xd1
        OUT     0x64,AL
        CALL    waitkbdout
        MOV     AL,0xdf         ; enable A20
        OUT     0x60,AL
        CALL    waitkbdout
```

等同于下面的代码

```c
#define KEYCMD_WRITE_OUTPORT     0xd1
#define KBC_OUTPORT_A20G_ENABLE  0xdf

    /* A20GATE的设定*/
    Wait_KBC_sendready();
    Io_out8(PORT_KEYCMD, KEYCMD_WRITE_OUTPORT);
    Waite_KBC_sendready();
    Io_out8(PORT_KEYDAT, KBC_OUTPORT_A20G_ENABLE);
    Waite_KBC_sendready();     /*这句话是为了等待完成执行指令*/
```

这样A20GATE信号线变成ON的状态，内存的1MB以上的部分就变成可用状态了。

接下来通过LGDT设定临时GDT，将CR0的值代入EAX切换到保护模式，这里牵扯到的CR0(control register 0)是一个特殊的寄存器，只有操作系统才能操作它

![](image\cr0.jpg)

当我们将它的最高位置为0，最低位置为1时，就进入到了不分页的保护模式。

这之后的代码基本都在执行memcpy的功能，在内存中传送各种数据，系统的内存分布图如下:

![](image\memdtr.png)

- 这里作者讲的有点不清不楚的，有几个地方没搞懂，所以梳理了一下流程及各文件的作用，以期对内容有更深入的理解

![](image\order.png)

ipl10.nas负责读盘到内存，读完盘之后跳转到0xc200处，即asmhead.nas。  
asmhead.nas负责显示模式及分辨率设置即从16位转换为32位保护模式，是C语言和汇编语言的桥梁，执行到最后就转到bootpack.c的主函数。  
bootpack.c包含主函数，做好初始化各种操作然后接收键盘和鼠标信息，并对信息进行解析，呈现在屏幕上，此外还有字库，鼠标显示，鼠标位置计算等等。这里用到了GDT和IDT，对消息的接收要用中断，对消息的保存要用FIFO缓冲区。  
dsctbl.c与GDT、IDT分段及中断相关。  
graphic.c负责设置调色板，显示字符串，绘制矩形，绘制鼠标，绘制窗口，大部分与VRAM相关的函数都在这里。  
int.c包括一些中断处理函数，但是这些并不是中断的真正入口，真正入口是对应的汇编函数，这里的函数是对应的汇编函数要调用的。这些函数处理键盘中断和鼠标中断，为了加速处理，要把收到的数据放进FIFO缓冲区，防止因为在中断中进行大量的处理而影响速度。  
fifo.c这是一个简单的用数组形式建立的FIFO循环链表。  
hankaku.txt是一个字库。  
naskfunc.nas有一些不能用C语言写的函数，必须用汇编语言，都放在这个文件里。

**ipl10.nas**

这部分主要负责先载入 启动扇区（0x7c00 ~ 0x7dff）
启动扇区载入完毕之后，将 IPL 软盘中除了启动扇区的那一块）载入到内存的 0x8200 ~ 0x34fff 区域（这里实际上只是载入了 10 个柱面 180KB）
跳转到 0xc200 处运行（这个地方实际就是 asmhead 的开始位置）

**asmhead.nas**

这部分的主要工作在之前已经提到过了
他将0x7c00 ~ 0x7dff 处的512byte的启动扇区数据拷贝到 0x100000 处（1MB 空间开始位置）
然后将 0x8200 ~ 0x34fff 处的IPL数据拷贝到 0x100200 处
同时将bootpack.hrb 的数据拷贝到0x280000位置处
最后跳转到 bootpack.hrb 处开始执行

**bootpack.c**

这部分实际就是我们 C 语言部分的操作， 用于处理键盘，鼠标中断响应， 图形绘制等操作

## 第九天
- 因为bootpack.c的代码又变的复杂了，再次整理代码，将设计键盘和鼠标的函数分别放到keyboard.c和mouse.c里。
- 进行内存管理首先要搞清楚内存有多大，需要写代码去检查内存。在检查内存的时候要先检测是否是486以后的CPU，如果是就暂时让CPU的高速缓存功能无效，否则写入和读出都是在缓存中进行的，结果所有的“内存”一切正常。可是在用如下函数去检查内存时，得到的内存容量是3072MB而不是设定的32MB

```c
unsigned int memtest_sub(unsigned int start, unsigned int end)
{
	unsigned int i, *p, old, pat0= 0xaa55aa55, pat1 = 0x55aa55aa;
	for(i = start; i <= end; i += 0x1000) {
		p = (unsigned int *) (i + 0xffc);
		old = *p;  //先记住修改前的值
		*p = pat0; //试写
		*p ^= 0xffffffff; //反转
		if (*p != pat1) { //检查反转结果
not_memory:
			*p = old;
			break;
		}
		*p ^= 0xffffffff; //再次反转
		if (*p != pat0) { //检查值是否恢复
			goto not_memory;
		}
		*p = old;  //恢复为修改前的值
	}
	return i;
}
```

这是什么原因造成的呢？原来是由于编译器太“聪明”了，在编译时它进行了最优化处理，结果我们的代码相当于下面这样子

```c
unsigned int memtest_sub(unsigned int start, unsigned int end)
{
unsigned int i;
for (i = start; i <= end; i += 0x1000) { }
return i;
}
```

也就是说，根本没有进行内存检查。

- 如果更改编译选项，停止最优化处理，是可以解决上述问题的，但我们在其他地方还是需要最优化处理的。这时候就需要我们的好帮手汇编语言出场了，将memtest_sub函数用汇编语言改写，这次可以得出正确的结果了。

- 作者采用了一种列表结构去存储内存管理信息，构建可用内存空间管理表，有关功能的编写类似于链表。这种方式占用内存少，分配和释放都很迅速，虽然管理程序变复杂了，但相比于效率的提高，这是值得的。还有一个缺点是，当可用空间变得零零散散，怎么都归纳不到一块儿时，会将空间管理信息全部用完。这时就要割舍掉小块内存（本节中是割舍掉了新来的信息），为了不在这个问题上纠结太久，作者采用了一种做法，即“割舍掉的东西，只要以后还能找回来，就暂时不去管它。”，留待以后解决。  