## 第十天
- 如果反复使用`memman_alloc`和`memman_free`进行以一字节为单位的内存管理，内存中就会出现很多不连续的小段未使用空间，这样就回吧man->frees耗尽。此次增加了两个以4KB为单位进行内存分配和释放的函数`memman_alloc_4k`和`memman_free_4k`来方便内存管理，使用了 **i = (i + 0xfff) & 0xfffff000** 的巧妙方法来进行向上舍入。
- 为了实现窗口的叠加，引入了图层（sheet）的概念，通过移动图层的方法实现鼠标指针和窗口的移动。新增函数位于sheet.c中，一开始的程序中，只要有移动就会对整个画面进行重绘，这无形中增加了许多不必要的开销（可能是由于电脑性能的提高，我并未观察到作者所说的现象）。通过增加一个`sheet_refreshsub`函数，我们可以指定重绘的范围从而提高速度。
## 第十一天
- 修改`sheet_refreshsub`功能，让它不刷新画面外的部分，使得鼠标能够移动到画面外。
- 精简函数，省略shtctl的指定。
- 描绘出一个窗口，构建方式与之前的方法相同，关闭按钮类似于鼠标指针，边框利用`boxfill8`函数画出，文字利用`putfont8_asc`放置。效果如下
![](image\myos.png)

- 将之前的窗口改成一个计数器，但在计数器工作时，会出现闪烁的现象。这是由于在刷新的时候，总是先刷新refresh范围内的背景图层，然后再刷新窗口图层，就会造成闪烁。如图
![](image\flash.png)
解决方法是仅对refresh对象及其以上的图层进行刷新，这样不仅避免了闪烁现象，还减小了刷新的开销。
- 但是我们的闪烁现象并未完全解决，将鼠标放在计数器的数字上面时，鼠标又闪烁起来了。想要解决此问题，需要在刷新窗口时避开鼠标所在的地方对VRAM进行写入处理，开辟一块内存，大小和VRAM一样，称之为map。之所以叫map是因为这块内存用来表示画面上的点是哪个图层的像素，所以它就相当于是图层的地图。
![](image\map.png)
在map写入信息，今后程序会对照map内容来向VRAM中写入。
## 第十二天
- 定时器对于操作系统非常重要，它的原理是每隔一段时间就发送一个中断信号给CPU，只要在中断处理程序中数一数定时器中断发生的次数就可以计算出经过了多长时间。
- 要在电脑中管理定时器，需要设定PIT（Programmable Interval Timer），PIT连接着IRQ0，所以设定了PIT就可以设定IRQ0的中断间隔。
    > IRQ0的中断周期变更:  
    AL=0x34:OUT(0x43,AL);  
    AL=中断周期的低8位; OUT(0x40,AL);  
    AL=中断周期的高8位; OUT(0x40,AL);  
    到这里告一段落。  
    如果指定中断周期为0，会被看作是指定为65536。实际的中断产生的频率是单位时间时钟周期数（即主频）/设定的数值。比如设定值如果是1000，那么中断产生的频率就是1.19318KHz。设定值是10000的话，中断产生频率就是119.318Hz。再比如设定值是11932的话，中断产生的频率大约就是100Hz了，即每10ms发生一次中断。

    下面的C语言代码即用于进行中断周期的变更
    ```c
    #define PIT_CTRL 0x0043
    #define PIT_CNT0 0x0040
    void init_pit(void)
    {
    io_out8(PIT_CTRL, 0x34);
    io_out8(PIT_CNT0, 0x9c);
    io_out8(PIT_CNT0, 0x2e);
    return;
    }
    ```
    同时我们还需要中断处理程序:
    ```c
    void inthandler20(int *esp)
    {
    io_out8(PIC0_OCW2, 0x60); /* 把IRQ-00信号接收完了的信息通知给PIC */
    /* 暂时什么也不做 */
    return;
    }
    ```
    ```x86asm
    _asm_inthandler20:
    PUSH ES
    PUSH DS
    PUSHAD
    MOV EAX,ESP
    PUSH EAX
    MOV AX,SS
    MOV DS,AX
    MOV ES,AX
    CALL _inthandler20
    POP EAX
    POPAD
    POP DS
    POP ES
    IRETD
    ```
    为了把这个中断处理程序注册到IDT，init_gdtidt函数中也要加上
    ```c
    set_gatedesc(idt + 0x20, (int) asm_inthandler20, 2 * 8, AR_INTGATE32);
    ```
    处理方法基本与之前的键盘和鼠标中断相同。

- 作者定义了一个名为TIMERCTL的结构体（目测以后还会对其进行扩展），改写init_pit和inthandler20增加了计数功能，数字以每秒钟100的速度增加，效果(不过看不出)如下
![](image\counter.png)
- 果不其然现在TIMERCTL变成了如下的样子
    ```c
    struct TIMERCTL {
    unsigned int count;
    unsigned int timeout;
    struct FIFO8 *fifo;
    unsigned char data;
    };
    ```
    至于为什么要这样做，是因为我们想要实现“超时”（timeout）功能。以上结构体中的timeout用来记录离超时还有多长时间，一旦这个剩余时间达到0，程序就往FIFO缓冲区里发送数据，定时器就是通过这种方法通知HariMain时间到了。
    写个程序试一下，在其中设定10秒钟以后向tiemerfifo写入“1”这个数据，而timerfifo收到数据时，就会在屏幕上显示“10[sec]"。
    ![](image\timeout.png)

- 操作系统中的很多地方，例如光标闪烁、时间显示等等都需要定时器，所以我们要设定多个定时器，定义如下结构体，修改相关函数
    ```c
    #define MAX_TIMER 500
    struct TIMER {
    unsigned int timeout, flags;
    struct FIFO8 *fifo;
    unsigned char data;
    };
    struct TIMERCTL {
    unsigned int count;
    struct TIMER timer[MAX_TIMER];
    };
    ```
    编写程序测试一下效果，如下:
    ![](image\manycounters.png)

- 由于inthandler20花费了很长时间来进行中断处理，妨碍了其它中断处理程序的执行，使得操作系统反应迟钝，所以作者用了很大的篇幅来讲怎么对其进行优化，从而加快中断处理。