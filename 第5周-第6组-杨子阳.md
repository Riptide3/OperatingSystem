## 第十三天
- 简化字符串显示，将一些常用的功能整理为一个函数。
- 重新调整FIFO缓冲区，将多个定时器的缓冲区合并为一个，通过往FIFO内写入不同数据来分辨出是哪个定时器超时。
- 性能真的提高了吗？-性能测试

    设置count变量，完全不显示计数，全力执行“cout++”，通过cout的值来测试系统性能。需要注意，必须在启动3秒后把count复位为0一次。

    > **起动 3 秒后，将 count 置为 0 的原因**  
    首先考虑一下这个命令的意思吧。起动3秒后把count复位至0，这与从3秒后开始计数是一样的。画面上要到10秒以后才显示，这样测试的时间就是7秒钟。  
    事实上，笔者最初并没有加入“count=0;”语句。但那样做的结果是，在真机上测定harib10d时，最高值和最低值的差值竟然达到了150054。这可了不得呀。差值这么大，即使我们比较harib10c和harib10d，也不知道哪个更快。  
    对于这样的结果，笔者曾茫然不知所措，差一点要放弃性能比较。但后来笔者忽然想起，只要某些条件稍微有些变化，电脑初始化所花费的时间就会有很大变化。这就是为什么我们在起动后3秒钟之内不进行测试的原因。这样做之后，误差急剧减小，终于可以比较结果了，真是太好了。 

    通过测试可以看出，系统的性能的确得到了提高。

- 再次调整FIFO缓冲区，将从键盘和鼠标输入的数据也归入计时器的FIFO中
    > 0～ 1 ………………… 光标闪烁用定时器  
    3 ………………… 3秒定时器  
    10 ………………… 10秒定时器  
    256～ 511 ………………… 键盘输入（从键盘控制器读入的值再加上256）  
    512～ 767 …… 鼠标输入（从键盘控制器读入的值再加上512）

    这样用一个FIFO缓冲区就可以正常进行处理了。

- 加快中断处理，之前的inthandler20和timer_settime中引入了太多的移位处理，浪费时间。此次修改通过链表来管理定时器，消除了移位处理。添加“哨兵”元素，简化链表插入时的复杂情况。

## 第十四天
- 继续测试性能
    添加以下函数
    ```c
    void set490(struct FIFO32 *fifo, int mode)
    {
        int i;
        struct TIMER *timer;
        if (mode != 0) {
            for (i = 0; i < 490; i++) {
                timer = timer_alloc();
                timer_init(timer, fifo, 1024 + i);
                timer_settime(timer, 100 * 60 * 60 * 24 * 50 + i * 100);
            }
        }
        return;
    }
    ```
    这样我们就设定了490个定时器。
    > 真机上运行结果的比较  
    (1) 追加490个定时器时的值 set490（&fifo, 1）;  
    harib11a:0096521077 ……harib10g  里加入 set490  的时候( 有移位)  
    harib11b:0096522038 ……harib10h  里加入 set490  的时候( 没有移位、没有哨兵)  
    harib11c:0096522097 ……harib10i  里加入 set490  的时候( 没有移位、有哨兵)  
    (2) 不追加490个定时器时的值 set490（&fifo, 0）;  
    harib11a:0096522095 ……harib10g  里加入 set490  的时候( 有移位)  
    harib11b:0096522038 ……harib10h  里加入 set490  的时候( 没有移位、没有哨兵)  
    harib11c:0096522101 ……harib10i  里加入 set490  的时候( 没有移位、有哨兵)  
    (3) 参考：不加入set490语句时的值  
    harib10g:0099969263 ……( 有移位)  
    harib10h:0099969184 ……( 没有移位、没有哨兵)  
    harib10i:0099969264 ……( 没有移位、有哨兵)  

    这里有一个有趣的现象，对于（2)和（3），处理上虽然完全相同，而结果却相差了345万左右，原因是什么呢？
    >这不是程序内容的问题，而是C编译器的问题。实际
    上，由于跳转目标地址不同，CPU的JMP指令执行的时钟周期数也不相同。在HariMain中，循环执行“count++；”的for语句虽然最终被编译为JMP指令执行，但如果前面加上“set490（&fifo,0）；”语句，那么以后各个指令的地址也都会相应地错开几个字节，结果造成JMP指令的地址也略有变化。因此执行时间也稍稍延迟，执行结果大约变差了3%.
    ```c
    for（;;） ｛                L2：
        count++;                count++;
        任意语句;          ->    任意语句;
    }                      JMP     L2
            这个L2的地址一旦变化，JMP的执行时间就变化！
    ```

- 提高分辨率

    使用VBE（VESA BIOS extension）可以切换到新画面模式，切换时要用"**AX = 0x4f02；BX = 画面模式号码**", VBE的的画面模式号码如下:
    >0x101 ……640× 480× 8bit  彩色  
    0x103 ……800× 600× 8bit  彩色  
    0x105 ……1024× 768× 8bit  彩色  
    0x107 ……1280× 1024× 8bit
    
    实际指定的时候，要将以上的画面模式号码值加上0x4000，再赋值到BX中去

    如果想在真机上运行我们则需要进行一系列的检查
    ```x86asm
    ; 确认VBE是否存在

		MOV		AX,0x9000
		MOV		ES,AX
		MOV		DI,0
		MOV		AX,0x4f00
		INT		0x10
		CMP		AX,0x004f
		JNE		scrn320

    ; 检查VBE的版本

		MOV		AX,[ES:DI+4]
		CMP		AX,0x0200
		JB		scrn320			; if (AX < 0x0200) goto scrn320

    ; 取得画面模式信息

		MOV		CX,VBEMODE
		MOV		AX,0x4f01
		INT		0x10
		CMP		AX,0x004f
		JNE		scrn320

    ; 画面模式信息的确认

		CMP		BYTE [ES:DI+0x19],8
		JNE		scrn320
		CMP		BYTE [ES:DI+0x1b],4
		JNE		scrn320
		MOV		AX,[ES:DI+0x00]
		AND		AX,0x0080
		JZ		scrn320		; 模式属性的bit7是0，所以放弃

    ; 画面模式的切换

		MOV		BX,VBEMODE+0x4000
		MOV		AX,0x4f02
		INT		0x10
		MOV		BYTE [VMODE],8	; 记录画面模式
		MOV		AX,[ES:DI+0x12]
		MOV		[SCRNX],AX
		MOV		AX,[ES:DI+0x14]
		MOV		[SCRNY],AX
		MOV		EAX,[ES:DI+0x28]
		MOV		[VRAM],EAX
		JMP		keystatus

    scrn320:
		MOV		AL,0x13			; VGA图、320x200x8bit彩色
		MOV		AH,0x00
		INT		0x10
		MOV		BYTE [VMODE],8	; 记录画面模式
		MOV		WORD [SCRNX],320
		MOV		WORD [SCRNY],200
		MOV		DWORD [VRAM],0x000a0000
    ```
    >在画面模式信息中，重要的信息有如下6个。
    WORD [ES : DI+0x00] :  模式属性……bit7  不是 1  就不好办( 能加上 0x4000)  
    WORD [ES : DI+0x12] : X  的分辨率  
    WORD [ES : DI+0x14] : Y  的分辨率  
    BYTE  [ES : DI+0x19] :  颜色数……必须为 8  
    BYTE  [ES : DI+0x1b] :  颜色的指定方法……必须为 4 (4  是调色板模式)  
    DWORD [ES : DI+0x28] : VRAM  的地址  
    在这6项信息当中，我们来确认如下3项：  
      颜色数是否为8  
      是否为调色板模式  
      画面模式号码可否加上0x4000再进行指定  

- 键盘输入

    查询下面的表，表里的值是按下键时的数值，在表里数值的基础上加0x80就可以得到键弹起时的数值。
    ![](image\keyboardtable.png)
    在HariMain中添加一些代码我们甚至已经可以实现下面的效果了
    ![](image\hellobupt.png)

- 窗口移动
  ```c
  if ((mdec.btn & 0x01) != 0) {
  /* 按下左键、移动sht_win */
  sheet_slide(sht_win, mx - 80, my - 8);
  }
  ```

  只用了短短几行代码我们就实现了窗口移动的功能，不过，它也有缺点，比如窗口会移动到鼠标点击的地方，而不只是拖动。

## 第十五天

- 任务切换，向CPU发出任务切换指令时，CPU会先把寄存器中的值全部写入内存中，这样做是为了当以后切换回这个程序的时候可以继续运行。为了把寄存器中的内容写入内存里去，我们需要任务状态段，即TSS（task status segment），TSS也是内存段的一种，需要在GDT中进行定义后使用
  ```c
  //TSS的结构
  struct TSS32 {
  int backlink, esp0, ss0, esp1, ss1, esp2, ss2, cr3;
  int eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi;
  int es, cs, ss, ds, fs, gs;
  int ldtr, iomap;
  };
  ```
  从开头的backlink起，到cr3为止的几个成员，保存的不是寄存器的数据，而是与人物设置相关的信息，在执行任务切换的时候这些成员不会被写入（backlink除外，某些情况下是会被写入的）  
  第二行的成员是32位寄存器，第三行是16位寄存器  
  EIP用来记录下一条需要执行的指令位于内存中哪个地址，当下次再返回这个任务的时候，CPU就可以明白应该从哪里读取程序来运行了。  
  ldtr和iomap也和第一行的成员一样，是有关人物设置的部分。

  JMP指令分为两种，只改写EIP的称为near模式，同时改写EIP和CS的称为far模式，在此之前我们使用的JMP指令基本上都是near模式的。下面这条之前写过的就是far模式的JMP指令
  ```c
  JMP  DWORD 2*8:0x0000001b
  ```
  这条指令在向EIP存入0x1b的同时，将CS置为2*8（=16）。

  创建TSS，将他们加入GDT，通过编写相关函数我们就能进行任务的切换了。