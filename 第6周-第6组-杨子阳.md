## 第十六天
- 由于多任务是一个操作系统非常重要的一部分，所以我们继续对多任务进行优化，仿造struct SHTCTL增添了一个struct TASKCTL。
```c
struct TASKCTL {
    int running; /*正在运行的任务数量*/
    int now; /*这个变量用来记录当前正在运行的是哪个任务*/
    struct TASK *tasks[MAX_TASKS];
    struct TASK tasks0[MAX_TASKS];
};
```
新增函数
> task_init: 将一个程序变成任务  
task_alloc: 初始化一个任务结构  
task_run: 将task添加到tasks的末尾，然后使running加一  
task_swicth: 当running为1时，不需要进行任务切换，函数直接结束。当running大于等于2时，先把now加1，然后把now所代表的任务切换成当前任务，最后再将末尾的任务移动到开头。  
task_sleep: 让任务休眠，如果要唤醒任务只需执行task_run。

- 在任务优先级的处理上，作者使用了多级队列调度的方式，如下图
![](image\multiplequeue.png)
这样在多任务的处理上，高优先级的任务，会得到更多的资源，避免了卡顿现象
![](image\multiplewindow.png)
## 第十七天
- 在之前的多任务管理中，如果任务A下面的LEVEL中有任务B0~B2，在任务A进入休眠状态后，mtask.c将自动寻找下层LEVEL中的任务，但如果我们没有启动B0~B2，程序就找不到其他的任务而导致运行出现异常。因此我们引入了一个"idle"(闲置)任务，并把它一直放在最下层的LEVEL中，这样一来，即便任务A进入休眠状态，系统也会自动切换到这个闲置任务，问题就得到解决了。而且闲置任务也很简单，它的功能只是执行HTL，代码如下
```c
void task_idle(void)
{
    for (;;) {
        io_hlt();
    }
}
```

- 创建命令行窗口，首先做一个新的任务命名为console_task，保留原先的task_a，结果如下
![](image\console1.png)

- 上面只是做了个窗口雏形，因此我们得让它接受字符输入，现在我们输入的字符都会跑到任务A的窗口中去，为了能够往命令行窗口中输入字符，我们要让系统在按下"Tab"键的时候，将输入窗口切换到命令行窗口上去。首先实现窗口标题栏颜色的切换，效果如下
![](image\console2.png)

- 想要向console_task的FIFO发送数据，需要知道FIFO的内存地址，基本上没有什么任务是完全用不到FIFO的，因此我们在struct TASK中加入struct FIFO
```c
struct TASK {
    int sel, flags; /* sel代表GDT编号 */
    int level, priority;
    struct FIFO32 fifo; /*这里！ */
    struct TSS32 tss;
};
```
功能的实现参照原先的代码，运行效果如下
![](image\console3.png)

- 经过之前的努力，我们可以输入英文、数字和符号了，但还无法输入“！”和“%”。为了能够输入这两个符号，我们必须要处理Shift键，Shift编码如下

    |       |按下|抬起|
    |-------|----|----|
    |左Shift|0x2a|0xaa|
    |右Shift|0x36|0xb6|
    准备一个key_shift变量，当左Shift按下时置为1，右Shift按下时置为2，两个都不按时置为0，两个都按下时置为3。使用两个不同的字符集，当key_shift为0时，我们用keytable0[]将按键编码转换为字符编码，而当key_shift不为0时，则使用keytable1[]进行转换。

运行结果如下
![](image\console4.png)

- 接下来要实现区分大小写字母的输入，我们要同时判断Shift键和CapsLock键的状态
    >CapsLock 为 为 OFF & Shift  键为 OFF  → 小写英文字母  
    CapsLock 为 为 OFF & Shift  键为 ON  → 大写英文字母  
    CapsLock 为 为 ON & Shift  键为 OFF  → 大写英文字母  
    CapsLock 为 为 ON & Shift  键为 ON  → 小写英文字母

    在asmhead.nas中，我们已经从BIOS获取到了键盘的状态，保存到了binfo->leds中
    >binfo->leds  的第 4  位 → ScrollLock  状态  
    binfo->leds  的第 5  位  → NumLock  状态  
    binfo->leds  的第 6  位  → CapsLock  状态

    只要使用上述数据，我们就可以处理大小写字母的输入了。

    运行一下，效果如图
    ![](image\console5.png)

- 通过编码表，我们可以得到：
    >0x3a: CapsLock  
    0x45: NumLock  
    0x46: ScrollLock

    当我们接收到上述按键编码时，只要将binfo->leds中对应的位置改写就可以了。到这里我们已经实现了锁定键模式的切换，不过键盘上的指示灯却不会变化，下面是关于键盘指示灯的控制
    > 关于LED的控制  
     对于NumLock和CapsLock等LED的控制，可采用下面的方法向键盘发送指令和数据。  
     读取状态寄存器，等待 bit 1的值变为 0。  
     向数据输出（0060）写入要发送的 1个字节数据。  
     等待键盘返回 1个字节的信息，这和等待键盘输入所采用的方法相同（用 IRQ等待或者用轮询状态寄存器 bit 1的值直到其变为 0都可以）。  
      返回的信息如果为 0xfa，表明 1个字节的数据已成功发送给键盘。如为 0xfe则表明发送失败，需要返回第 1步重新发送。  
      要控制LED的状态，需要按上述方法执行两次，向键盘发送EDxx数据。其中，xx的bit0代表ScrollLock，bit 1代表NumLock，bit 2代表CapsLock（0表示熄灭，1表示点亮）。bit 3～7为保留位，置0即可。

    通过合理的编写程序就可以对键盘指示灯进行控制了。

## 第十八天
- 控制光标闪烁，将按下Tab键时的处理以及光标闪烁的处理改写了，当不想显示光标的时候，使cursor_c为负值。
- 使命令行窗口支持回车和滚动
- 命令行支持mem命令，用来显示内存使用情况；cls命令，清空屏幕内容；dir命令，显示文件信息。
- 以上除dir命令外涉及到的内容都不多，对于dir命令，要显示文件名信息，我们需要读取磁盘的内容，这得借助BIOS的帮助。在进入32位模式之前，我们已经从磁盘中读了10个柱面的内容。
    >那么已经读出来的这些数据，存放在内存中的什么地方呢？在8.5节中写得很清楚，是 0x00100000～0x00267fff。其中存放文件名的地方又在哪里呢？其实我们也已经说过了，不过大家可能都不记得了吧，参考3.5节从0柱面、0磁头、1扇区开始的0x002600之后，也就是内存地址的0x00102600开始写入。

做个试验，在磁盘映像中加入haribote.sys、ipl10和make.bat三个文件。
磁盘映像中0x002600字节以后的部分，内容如下
```
       +0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F 0123456789ABCDEF
-------------------------------------------------------------------------
002600 48 41 52 49 42 4F 54 45 53 59 53 20 00 00 00 00 HARIBOTESYS ....
002610 00 00 00 00 00 00 18 74 FF 32 02 00 68 6B 00 00 .......t.2..hk..
002620 49 50 4C 31 30 20 20 20 4E 41 53 20 00 00 00 00 IPL10 NAS ....
002630 00 00 00 00 00 00 59 7A 42 41 38 00 95 0B 00 00 ......YzB58.....
002640 4D 41 4B 45 20 20 20 20 42 41 54 20 00 00 00 00 MAKE BAT ....
002650 00 00 00 00 00 00 F6 10 81 30 3E 00 2E 00 00 00 .........0>.....
002660 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
```

这里的内容是以32字节为单位循环的，这32个字节的结构如下
```c
struct FILEINFO {
    unsigned char name[8], ext[3], type;
    char reserve[10];
    unsigned short time, date, clustno;
    unsigned int size;
};
```

开始的8个字节是文件名，文件名不足8个字节时用空格补足，如果文件名的第一个字节为0xe5，代表这个文件已经被删除了；文件名第一个字节为0x00，代表这一段不包含任何文件名信息。接下来的3个字节是扩展名，和文件名一样不足3个字节时用空格不足。后面1个字节存放文件的属性信息，一般的文件不是0x20就是0x00。

属性信息说明如下
```
0x01······只读文件（不可写入）
0x02······隐藏文件
0x04······系统文件
0x08······非文件信息（比如磁盘名称等）
0x10······目录
```

当一个文件既是只读文件又是隐藏文件时，将上面的对应值加算即可，即0x03。
接下来的10个字节为保留，下面2个字节为WORD整数，存放文件的时间。接下来的2个字节也是WORD整数，代表这个文件的内容从磁盘上的哪个扇区开始存放，是簇号（cluster number），最后的4个字节为DWORD整数，存放文件的大小。

执行一下我们写好的命令，结果如图
![](image\cmd1.png)
![](image\cmd2.png)
![](image\cmd3.png)