## 第十九天
- 实现type命令，首先我们有一个公式 **磁盘映像中的地址 = clustno * 512 + 0x003e00**，有了这个公式就可以找到文件存放的位置，接下来只要将文件的内容逐字节读取出来并显示在屏幕上就可以了。在输出时，要注意对制表符，换行符和回车符的处理，否则输出就会错位。特殊字符编码如下
```
0x09 ……制表符：显示空格直到 x  被 4  整除为止
0x0a ……换行符：换行
0x0d ……回车符：忽略
```
- 对FAT的支持，按照Windows管理磁盘的方法，保存大于512字节的文件时，有时候并不是存入连续的扇区中。对于文件的下一段存放在哪里，磁盘是有记录的，这个记录存储在从0柱面、0磁头、2扇区开始的9个扇区中，在磁盘映像中相当于0x000200 ~ 0x0013ff，这个记录被称为FAT（file allocation table）。不过FAT使用了微软的算法进行压缩，需要用下面的方法进行解压缩

    F0 FF FF → FF0 FFF  
    ab cd ef → dab efc


```
       +0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F 0123456789ABCDEF
-----------------------------------------------------------------------
000200 F0 FF FF 03 40 00 05 60 00 70 80 00 09 A0 00 0B ....@..`........
000210 C0 00 0D E0 00 0F 00 01 11 20 01 13 40 01 15 60 ......... ..@..`
000220 01 17 80 01 19 A0 01 1B C0 01 1D E0 01 1F 00 02 ................
000230 21 20 02 23 40 02 25 60 02 27 80 02 29 A0 02 2B .......&.29.....
000240 C0 02 2D E0 02 2F 00 03 31 20 03 33 40 03 35 60 ..-../..1 .3@5.`
000250 03 37 80 03 39 F0 FF 3B C0 03 3D E0 03 3F F0 FF .7..9..;..=..?..
000260 FF 0F 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
000270 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
```

对上面的FAT进行解压缩的话就会得到如下的数据
```
    +0  +1  +2  +3  +4  +5  +6  +7  +8  +9
------------------------------------------
 0 FF0 FFF 003 004 005 006 007 008 009 00A
10 00B 00C 00D 00E 00F 010 011 012 013 014
20 015 016 017 018 019 01A 01B 01C 01D 01E
30 01F 020 021 022 023 024 025 026 027 028
40 029 02A 02B 02C 02D 02E 02F 030 031 032
50 033 034 035 036 037 038 039 FFF 03B 03C
60 03D 03E 03F FFF FFF 000 000 000 000 000
```

以haribote.sys为例，已知clustno = 2，因此读取0x004200 ~ 0x0045ff这512个字节，接下来看FAT的第2号记录，其值为003，也就是说下面的部分存放在clustno = 3这个位置，以此类推，我们一直读取到clustno = 57，而在FAT的第57号记录中存储的是FF
F，也就是说57号之后已经没有数据了，即这里就是文件的末尾。**一般来说，如果遇到FF8 ~ FFF的值，就代表文件数据到此结束**。

由于FAT文件非常重要，微软在磁盘中存放了2份FAT，第一份位于0x000200 ~ 0x0013ff，第二份位于0x001400 ~ 0x0025ff，其中第二份是备份，内容与第一份完全相同。

- 整理一下bootpack.h开始写第一个应用程序
```x86asm
[BITS 32]
    CLI
fin:
    HLT
    JMP fin
```
将上面这段代码保存为hlt.nas，然后用nask进行汇编，生成hlt.hrb。这个扩展名hrb就相当于Windows下的exe。将文件的内容读到内存，我们为其创建一个内存段，接下来只要goto到该段中的程序，程序就会开始运行了。

## 第二十天
- 实现API
![](image\api.png)
在应用程序对API执行CALL的时候，要使用far-CALL，如下
```x86asm
CALL    2*8:0xbe3
```
因此返回的时候必须使用相应的far-RET，即RETF指令
```x86asm
_asm_cons_putchar:
    （中略）
        RETF ; 这里！
```
- 可是如果我们修改了操作系统的代码，_asm_cons_putchar的地址会随着改变，这样我们的应用程序也要重写，这显然是不现实的。IDT中最多可以设置256个函数，IRQ使用了16个，CPU用于通知异常状态的中断最多也只有32种，因此还剩下很多没有使用的项，所以我们就从IDT中找一个空闲的项用一下，我们就选0x40号（0x30 ~ 0xff均可），并将_asm_cons_putchar注册在这里。这样用INT 0x40就可代替原来的地址调用，返回指令也要相应的改成IRETD。用INT调用时，对于CPU来说相当于执行了中断处理程序，因此在调用的同时CPU会自动执行CLI指令来禁止中断请求，但我们并不需要禁止中断，因此需要在开头添加一条STI指令。
- 增加两个用于显示字符串的API，如果一直用之前的方式将他们设置为中断函数的话256个项目的IDT很快就会被用光。这里借鉴BIOS的调用方式，在寄存器中存入功能号，用EDX来存放功能号，就可以设置最多达42亿个API函数。
```
功能号 1……显示单个字符（AL = 字符编码）  
功能号 2……显示字符串 0（EBX = 字符串地址）  
功能号 3……显示字符串 1（EBX = 字符串地址，ECX = 字符串长度）
```
改写_asm_cons_putchar
```x86asm
_asm_hrb_api:
        STI
        PUSHAD ; 用于保存寄存器值的PUSH
        PUSHAD ; 用于向hrb_api传值的PUSH
        CALL _hrb_api
        ADD ESP,32
        POPAD
        IRETD
```
用C语言编写的API处理程序如下
```c
void hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)
{
    struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec);
    if (edx == 1) {
        cons_putchar(cons, eax & 0xff, 1);
    } else if (edx == 2) {
        cons_putstr0(cons, (char *) ebx);
    } else if (edx == 3) {
        cons_putstr1(cons, (char *) ebx, ecx);
    }
    return;
}
```
## 第二十一天
- 在显示单个字符时，我们用[CS:ECX]的方式特意指定了CS，因此可以成功读取msg的内容，但在显示字符串时，由于无法指定段地址，程序误以为是DS而从完全错误的内存地址中读取了内容，所以显示就会出错。hrb_api并不知道代码段的起始位置位于内存的哪个地址，但cmd_app应该知道，因为代码段是由cmd_app设置。由于没有办法从cmd_app向hrb_api直接传递数据，所以我们像之前保存cons的地址一样，将它放在0xfe8，然后用类似与**cons_putstr0(cons, (char *) ebx + cs_base);**这样的调用方法就能正确读取内容了。
- 我们希望做到用C语言编写应用程序，例如
```c
a.c

void api_putchar(int c);
void HariMain(void)
{
    api_putchar('A');
    return;
}
```
api_putchar函数，需要用汇编语言编写，功能是向EDX和AL赋值，并调用INT 0x40，
```x86asm
a_nask.nas

[FORMAT "WCOFF"] ; 生成对象文件的模式
[INSTRSET "i486p"] ; 表示使用486兼容指令集
[BITS 32] ; 生成32位模式机器语言
[FILE "a_nask.nas"] ; 源文件名信息
            GLOBAL _api_putchar
[SECTION .text]
_api_putchar:   ; void api_putchar(int c);
        MOV     EDX,1
        MOV     AL,[ESP+4] ; c
        INT     0x40
        RET
```
这里的api_putchar需要与a.c的编译结果进行连接。

不过这样生成的hrb还是不能运行，我们需要将a.hrb开头的6个字节替换成“E8 16 00 00 00 CB”。这六个字节就相当于下面三行代码汇编之后的结果
```x86asm
[BITS 32]
        CALL 0x1b
        ETF
```
也就是先调用0x1b这个地址的函数，从函数返回后再执行far-RET，这里的0x1b就是.hrb文件中HariMain的地址。

添加如下的代码就可让我们在读取数据到内存中时，先修改前六个字节再运行
```c
if (finfo->size >= 8 && strncmp(p + 4, "Hari", 4) == 0) { /*从此开始*/
    p[0] = 0xe8;
    p[1] = 0x16;
    p[2] = 0x00;
    p[3] = 0x00;
    p[4] = 0x00;
    p[5] = 0xcb;
} /*到此结束*/
```
- 保护操作系统，有一些电脑病毒或恶意软件，或者是应用程序的bug，可能会对操作系统造成破坏，造成死机等情况，所以我们需要操作系统的保护机制。

例如
```c
void HariMain(void)
{
    *((char *) 0x00102600) = 0;
    return;
}
```
上述程序擅自访问了本该由操作系统来管理的内存空间，对于这种情况，我们需要为应用程序提供专用的内存空间，要做到这一点，我们可以创建应用程序专用的数据段，并在应用程序运行期间，将DS和SS指向该段地址。
```
操作系统用代码段……2 * 8
操作系统用数据段……1 * 8
应用程序用代码段……1003 * 8
应用程序用数据段……1004 * 8
（3 * 8～1002 * 8为TSS所使用的段）
```
接着作者写了很多用于段切换的函数，看的云里雾里的，结果到最后说CPU其实提供了这种进行段切换的功能，无需我们自己去写。
- 接下来实现强制结束程序，只要在中断号0x0d中注册一个函数即可，因为在x86架构规范中，当应用程序试图破坏操作系统时或者试图违背操作系统的设置时，就会自动产生0x0d中断，因此该中断也被称为“异常”。
- 操作系统会指定应用程序用的DS，因此破坏行为会发生异常，那么如果应用程序忽略操作系统指定的DS，用汇编语言直接将操作系统用的段地址存入DS的话，就可以破坏操作系统。我们要对这种情况进行处理，在段定义的地方，如果将访问权限加上0x60的话，就可以将段设置为应用程序用，当CS中的段地址为应用程序用段地址时，CPU会认为“当前正在运行应用程序”，这时如果存入操作系统用的段地址就会产生异常。如果使用这样的方法，就必须在TSS中注册操作系统用的段地址和ESP，这样才能实现内核态和用户态之间的切换，我们自己写的段切换也就不需要了。IDT中的INT 0x40的访问权限也要加上0x60，让它成为“可供应用程序作为API调用的中断”。