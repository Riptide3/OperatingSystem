## 第二十二天
- 经过我们之前的一番设置，操作系统得到了很好的保护，一般的攻击手段已经不起作用了。

    在操作系统的内存空间里搞破坏行不通了，在定时器上动手脚呢？
```x86asm
[INSTRSET "i486p"]
[BITS 32]
        MOV AL,0x34
        OUT 0x43,AL
        MOV AL,0xff
        OUT 0x40,AL
        MOV AL,0xff
        OUT 0x40,AL
; 上述代码的功能与下面代码相当
; io_out8(PIT_CTRL, 0x34);
; io_out8(PIT_CNT0, 0xff);
; io_out8(PIT_CNT0, 0xff);
        MOV EDX,4
        INT 0x40
```
然而上述代码并不会对我们的操作系统造成破坏，当以应用模式运行时，执行IN指令和OUT指令都会产生一般保护异常。

如果执行CLI再HLT呢？
```x86asm
[INSTRSET "i486p"]
[BITS 32]
        CLI
fin:
        HLT
        JMP     fin
```
依旧不能破坏系统，当以应用程序模式运行时，执行CLI、STI和HLT这些指令都会产生异常。

操作系统里有一个用来CLI的函数，far-CALL这个函数呢？
```x86asm
[INSTRSET "i486p"]
[BITS 32]
        CALL 2*8:0xac1
        MOV EDX,4
        INT 0x40
```
还是不能对操作系统进行破坏，如果应用程序可以CALL任意地址的话，像这样就能破坏操作系统了，因此CPU规定除了设置好的地址以外，禁止应用程序CALL其他的地址。

但是如果我们对API进行修改的话还是可以破坏操作系统的，如果操作系统内部的API本身就有BUG，那我们用户就无能为力了，想要防止这种问题的发生，我们只能“不安装不可靠的操作系统”了。
- 帮助发现BUG
    如果我们写出了有bug的代码，如
    ```c
    void api_putchar(int c);
    void api_end(void);

    void HariMain(void)
    {
        char a[100];
        a[10] = 'A'; /*这句当然没有问题*/
        api_putchar(a[10]);
        a[102] = 'B'; /*这句就有问题了*/
        api_putchar(a[102]);
        a[123] = 'C'; /*这句也有问题了*/
        api_putchar(a[123]);
        api_end();
    }
    ````
    由于a是保存在栈中的，因此这次会产生栈异常。我们需要一个函数来处理栈异常，栈异常的中断号为0x0c。PS：根据CPU说明书，从0x00到0x1f都是异常所使用的中断。仿照inthandler0d函数，编写inthandler0c函数，然后将其注册到IDT中。在真机环境下，显示出“AB”之后才产生异常，为什么写入“B”不会产生异常呢？是因为虽然a[102]超出了数组的边界，但却没有超出为应用程序分配的数据段边界，而a[123]所在的地址已经超出了数据段的边界，因此写入“C”会产生异常。

    在异常处理程序中，加入如下代码
    ```c
    sprintf(s, "EIP = %08X\n", esp[11]);
    cons_putstr0(cons, s);
    ```
    其功能是，将esp的11号元素（即EIP）显示出来，这样我们就能知道引发异常的指令的地址。
    
    其他元素有
    ```x86asm
    esp[ 0] : EDI
    esp[ 1] : ESI esp[0 ～7] 为_asm_inthandler 中PUSHAD 的结果
    esp[ 2] : EBP
    esp[ 4] : EBX
    esp[ 5] : EDX
    esp[ 6] : ECX
    esp[ 7] : EAX
    esp[ 8] : DS esp[8 ～9] 为_asm_inthandler 中PUSH 的结果
    esp[ 9] : ES
    esp[10] : 错误编号（基本上是0，显示出来也没什么意思）
    esp[11] : EIP
    esp[12] : CS esp[10 ～15] 为异常产生时CPU 自动PUSH 的结果
    esp[13] : EFLAGS
    esp[14] : ESP （应用程序用ESP ）
    esp[15] : SS （应用程序用SS
    ```
- 强制结束应用程序

    如果我们运行一个，类似于下面这样的程序
```c
void HariMain(void)
{
    for (;;) { }
}
```
它将永远循环下去而无法结束，中断并没有被禁用，因此其他的任务还可以照常工作，不过这个任务总归要消耗一定的CPU运行时间，系统整体的速度就会变慢，因此我们需要强制结束应用程序的方法。

```C
if (i == 256 + 0x3b && key_shift != 0 && task_cons->tss.ss0 != 0) { /* Shift+F1 */
    cons = (struct CONSOLE *) *((int *) 0x0fec);
    cons_putstr0(cons, "\nBreak(key):\n");
    io_cli(); /*不能在改变寄存器值时切换到其他任务*/
    task_cons->tss.eax = (int) &(task_cons->tss.esp0);
    task_cons->tss.eip = (int) asm_end_app;
    io_sti();
```
上述程序的工作原理是，当按下强制结束键（shift + F1）时，改写命令行窗口任务的的寄存器值，并goto到asm_end_app。
```c
_asm_end_app:
; EAX为tss.esp0的地址
        MOV ESP,[EAX]
        MOV DWORD [EAX+4],0 ; 这里！
        POPAD
        RET ; 返回cmd_app
```
这样一来程序会被强制结束，但也有个问题，那就是当应用程序没有在运行的时候，按下强制结束键会发生误操作。所以我们必须要确认task_cons->tss.ss0不为0时才能继续进行处理。我们还得进行一些修改，使得当应用程序运行时，该值一定不为0；而当应用程序没有运行时，该值一定为0，为此，我们在在task_alloc加入`task->tss.ss0 = 0;`。

- 我们写好了显示字符串的API，然后要写一个C语言调用该API的函数，如下
```
_api_putstr0: ; void api_putstr0(char *s);
        PUSH EBX
        MOV EDX,2
        MOV EBX,[ESP+8] ; s
        INT 0x40
        POP EBX
        RET
```
但是我们在程序中使用该函数的时候，却不能显示字符。这是为什么呢?

在API函数中，显示字符串时需要字符串的首地址，若应用程序是通过bim2hrb生成的话，程序还会链接obj文件，生成的hrb文件分为两个部分——代码部分和数据部分。不过我们之前一直没有考虑数据部分，当程序中没有字符串和外部变量时，就会生成不含数据部分的hrb文件，因此之前的程序都不会出现问题。

.hrb文件的数据部分会在应用程序启动时被传送到应用程序用的数据段中，而.hrb文件中数据部分的位置则存放在代码部分的开头一块区域中，由bim2hrb生成的.hrb文件，开头的36个字节不是程序，而是存放了下列这些信息
```
0x0000 (DWORD)  …… 请求操作系统为应用程序准备的数据段的大小
0x0004 (DWORD)  …… “Hari”（.hrb 文件的标记）
0x0008 (DWORD)  …… 数据段内预备空间的大小
0x000c (DWORD)  …… ESP 初始值& 数据部分传送目的地址
0x0010 (DWORD)  …… hrb 文件内数据部分的大小
0x0014 (DWORD)  …… hrb 文件内数据部分从哪里开始
0x0018 (DWORD)  …… 0xe9000000
0x001c (DWORD)  …… 应用程序运行入口地址 - 0x20
0x0020 (DWORD)  …… malloc空间的起始地址
```
E9是JMP指令的机器码，跳转的偏移地址为应用程序入口地址 - 0x20。

当启动应用程序时，操作系统为应用程序分配了代码段和数据段，启动前应该先将hrb文件中的数据复制到数据段再执行应用程序。
- 显示窗口/在窗口中描绘字符和方块，操作系统已经有了显示窗口以及显示字符和方块的函数，可以在hrb_api中调用，只需要确定一下功能号并且正确传参即可实现显示窗口以及在窗口上显示文字的功能。
## 第二十三天
- 编写malloc函数，我们已经有了一个memman_alloc函数，但是因为memman_alloc函数分配的内存空间并不位于应用程序的数据段范围内，所以我们需要编写一个为应用程序分配内存空间的API函数，然后将malloc的内存空间首地址写到hrb文件中去，这样可以有效减小hrb文件的大小。

malloc函数要想实现分配内存的功能，那么操作系统就需要提前给应用程序预留一定大小的空间用于malloc，因为应用程序所需要的内存空间不好预测，最好的做法是用于给malloc分配的内存空间可以调整大小，但是在我们自制的操作系统中暂时没有实现这样的功能，只能给malloc函数预留一定大小的空间，这应该是一个需要优化的地方。实现malloc函数的同时，我们当然也要实现一个free函数

编写API函数malloc和free的思路：  
1. 使用memman_init函数初始化一个memman，参数中的地址要写应用程序段的地址
2. 使用memman_free函数释放空间，为应用程序的malloc预留这段空间
3. 使用memman_alloc函数可以为应用程序分配空间
4. 使用memman_free函数可以释放分配的内存空间
- 画点/画线，想要在任务的界面上显示一些内容，只需要在对应图层的buf中填写相应的内容，然后刷新图层即可。之前的图层SHEET定义如下：
```c
struct SHEET
{
	unsigned char *buf;  /*用来记录图层上所描画内容的地址*/
	int xsize,ysize,x,y,color,height,flags;
	struct SHTCTL *ctl;	
};
```
1. 若要在窗口上显示一个点，那么就在对应图层的buf中修改一个单元的内容即可。
2. 若要在窗口上显示多个点，那么就在对应图层的buf中修改多个单元的内容即可。
3. 可以画点就可以画线，只要确定了线的起点坐标和终点坐标，就可以画出这条线。

画线方法：

设起点（x0，y0），终点（x1，y1）

1. 求横纵坐标差值的绝对值：dx = |x1 - x0|，dy = |y1 - y0|
2. 比较dx和dy，确定点的个数len：  
        a. 若dx >= dy, len = dx + 1, dx = 1, dy = dy / len, 若x0 < x1, dy = -dy, 若y0 < y1, dy = -dy
        b. 若dx < dy, len = dy + 1, dy = 1, dx = dx / len, 若x0 < x1, dx = -dx, 若y0 < y1, dy = -dy

3. x = x0, y = y0
        按如下方式画len个点：  
        画点（x，y），x += dx, y += dy
- 现在我们可以在窗口上画点、画线了，不过一个问题出现了，在应用程序结束之后，窗口依然还留在画面上。这是因为系统为留在画面上的这个窗口分配了应用程序的数据段作为存放窗口图层的内存空间，当应用程序活动时没有任何问题，但当应用程序运行结束后，其数据段的内存空间就被释放出来，供操作系统及其他应用程序来使用，所以这样不行。在应用程序结束之前，我们需要先关闭窗口。该功能的实现也很简单，我们只需要在API函数api_closewin中调用sheet_free函数即可。
- 想要实现按下某个按键关闭窗口的功能，我们需要API实现函数get_key，其返回值为按键编码。我们通过循环不断从FIFO中取出数据直到FIFO为空或成功接收到键盘输入后循环结束，在此过程中FIFO还会收到诸如计时器光标ON、OFF之类的数据，我们需要简单地将它们处理掉。为了设置定时器，我们需要timer的地址，不过这是console_task中的变量，hrb_api是无法获取的，所以我们将定时器加入到struct CONSOLE中了，因为这个定时器是用来控制光标闪烁的，对于命令行窗口来说是必需的。这里的键盘输入API提供了阻塞和非阻塞两种方式，如果是非阻塞，则当FIFO为空时立即返回-1；如果是阻塞，则当FIFO为空时任务休眠并等待。
- 如果我们按Shift + F1强制结束程序的话，窗口还是会残留在界面上，所以我们在struct SHEET中添加一个用来存放task的成员，当应用程序结束时，查询所有的图层，如果图层的task为将要结束的应用程序，则关闭该图层。
## 第二十四天
- 首先实现用键盘鼠标切换窗口、用鼠标移动窗口和用鼠标关闭窗口的功能，这几个功能实现起来很简单。我们使用按键F11来作为窗口切换的按键，按下F11，我们就将从下面数第2个图层的高度提升为shtctl->top-1，shtctl->top这个高度存放的是最上面一个图层的高度，这个图层永远是绘制鼠标用的。使用鼠标切换时，我们按照图层从上到下的顺序寻找鼠标所指向的图层，最先找到的图层就是鼠标指向的图层，找到之后，将该图层的高度提升为shtctl->top-1。窗口移动是基于鼠标移动进行的，当鼠标按下鼠标左键时，鼠标位于所选中图层的标题栏，那么此时该图层跟随鼠标一起移动。只要记录下鼠标移动的横坐标以及纵坐标，就可以计算出其移动的距离，图层也移动同样的距离即可。
对于用鼠标关闭窗口的功能，只要判断鼠标按下时其坐标是否是在“X”按钮上，就可以实现。
- 虽然我们已经实现了让应用程序接受键盘输入的功能，不过仔细看画面发现，处于输入状态的其实是命令行窗口，我们想要让应用程序处于输入状态。之前我们所使用的Tab键切换很简单，只能在两个窗口之间交替进行，但是现在我们有3个以上的窗口，我们这样规定，按下Tab键时将键盘输入切换到当前输入窗口下面一层的窗口中，若当前窗口为最下层则切换到最上层窗口。当应用程序窗口处于输入模式时被关闭，我们让系统自动切换到最上层的窗口。  
我们用SHEET结构中的task成员来判断数据发送对象的FIFO，因此在sht_cons->task中也加入了TASK结构的地址，这样的话我们就无法分辨窗口是不是由应用程序生成的，于是我们需要通过SHEET结构中的flags成员的0x10比特位来分辨窗口是不是由应用程序生成的，当该比特位为1时，表示该窗口是应用程序窗口；使用SHEET结构中的flags成员的0x20比特位来分辨该窗口是否需要光标控制。
- 刚才为了实现用Tab键切换，我们修改了很多代码，这次我们只需要添加一点点代码就可以实现用鼠标切换输入窗口了，如下
```c
if (sht != key_win) {
        cursor_c = keywin_off(key_win, sht_win, cursor_c, cursor_x);
        key_win = sht;
        cursor_c = keywin_on(key_win, sht_win, cursor_c);
 }
```
- 关于定时器的部分，操作系统已经实现了定时器的功能，但是应用程序没有办法使用，我们可以使用API的方式使得应用程序也可以使用定时器。首先我们需要确定关于定时器操作的API的功能号以及参数，然后按照以前编写API的方式编写API。要注意应用程序结束之后一定要取消应用程序中的定时器，要不然该定时器就会给命令行本身发送数据，而命令行本身肯定是一头雾水。