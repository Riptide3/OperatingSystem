## 第二十五天
### 增加蜂鸣器发声的功能
- 蜂鸣器的发声和定时器一样，是由PIT来控制的
>   蜂鸣器发声的控制  
　　  音高操作  
　　  AL = 0xb6; OUT(0x43, AL);  
　　  AL = 设定值的低位 8bit; OUT(0x42, AL);  
　　  AL = 设定值的高位 8bit; OUT(0x42, AL);  
　　  设定值为 0时当作 65536来处理。  
　　  发声的音高为时钟除以设定值，也就是说设定值为 1000时相当于发出 1.19318KHz的声音；设定值为 10000时相当于 119.318Hz。因此设定 2712即可发出约 440Hz的声音  
  蜂鸣器ON/OFF  
　　  使用 I/O端口 0x61控制。  
　　  ON：IN(AL, 0x61); AL |= 0x03; AL &= 0x0f; OUT(0x61, AL);  
　　  OFF：IN(AL, 0x61); AL &= 0xd; OUT(0x61, AL);

- 这里的时钟是PIT时钟而不是CPU时钟，频率恒定为1.19318MHz。API设计如下
> 蜂鸣器发声
EDX=20  
EAX=声音频率（单位是mHz，即毫赫兹）  
例如当EAX=4400000时，则发出440Hz的声音  
频率设为0则表示停止发声

- 程序的编写很简单，不过遗憾的是我们用的模拟器并没有模拟蜂鸣器发声的功能

- 到目前为止，我们的操作系统只用了16种颜色，但我们已经用上了256色的显示模式，还有240种颜色可以用，所以我们要修改一下操作系统，增加可以显示的颜色。为三原色中每种颜色赋予6个色阶，这样就可以定义出216种颜色，没定义的就只剩下24种颜色了，不过这样会产生8种重复的颜色，编写程序显示效果如下  
![](image\color.png)

- 我们还有一种方式可以让颜色变得更加丰富，使用颜色交替排列的方式，将两种颜色混合在一起，混合方式有3种，这样虽然只有6级色阶，但却可以显示出21阶色阶  
![](image\mix.png)

- 显示效果更加平滑  
![](image\color2.png)

- 迄今为止我们还不能实现同时启动两个以上的应用程序，如果修改命令行窗口使其在应用程序运行中就可以输入下一条命令的修改量太大，所以作者打算同时启动两个命令行窗口，同时删掉task_a，这样我们的操作系统更像一个真正的操作系统了
![](image\morelikerealos.png)

## 第二十六天
- 窗口移动的速度很慢，所以打算对窗口移动进行提速。窗口移动慢的原因之一就是sheet_refreshmap的速度太慢。此函数中有如下语句
```c
for (by = by0; by < by1; by++) {
    vy = sht->vy0 + by;
    for (bx = bx0; bx < bx1; bx++) {
        vx = sht->vx0 + bx;
        if (buf[by * sht->bxsize + bx] != sht->col_inv) {
            map[vy * ctl->xsize + vx] = sid;
        }
    }
}
```
其中的if语句位于三层for循环中被执行了很多次，因此如果能去掉这个if语句的话，速度应该会有不小的提高。

- 这个if语句的功能是判断图层是否为透明部分，如果强行去掉它鼠标指针就会变成一个方块，不过我们的窗口基本都是矩形的，没有透明部分，如果仅去掉窗口部分的if判断是没有影响的。所以我们将程序修改成如下的样子
```c
if (sht->col_inv == -1) {
    /*无透明色图层专用的高速版*/
    for (by = by0; by < by1; by++) {
        vy = sht->vy0 + by;
        for (bx = bx0; bx < bx1; bx++) {
            vx = sht->vx0 + bx;
            map[vy * ctl->xsize + vx] = sid;
        }
    }
} else {
    /*有透明色图层用的普通版*/
    for (by = by0; by < by1; by++) {
        vy = sht->vy0 + by;
        for (bx = bx0; bx < bx1; bx++) {
            vx = sht->vx0 + bx;
            if (buf[by * sht->bxsize + bx] != sht->col_inv) {
                map[vy * ctl->xsize + vx] = sid;
            }
        }
    }
}
```

- 在sheet_refreshmap中有这样一句
```c
map[vy * ctl->xsize + vx] = sid;
```
这个命令的功能是向内存中某个地址写入sid的值，它也位于for循环中会被反复执行，而且这个地址后面以及再后面的地址也要写入sid的值。在汇编语言中，如果我们用32位寄存器来执行MOV指令的话，仅一条指令就可以向相邻的4个地址写入值，只要指定地址是4的整数倍，指令的执行速度就和一个字节的MOV是相同的，也就是说速度可以提高4倍。因此，为了让这次的修改发挥最大的效果，我们需要使窗口在x方向上的大小为4的倍数，而且窗口的x坐标也要为4的倍数，目前所有的窗口大小都是4的倍数，所以不需要修改，而对于窗口坐标，我们需要做AND运算来取整，使打开窗口时的显示位置为4的倍数，使用鼠标拖动窗口时的目的地坐标保证是4的倍数。一次性写入4个字节的办法可以有效地提高速度，所以其它函数中的有关语句我们也可以修改，例如sheet_refreshsub。

- 窗口移动的速度变快了，但是还是跟不上鼠标的移动速度，在放开鼠标键之后窗口还在移动。这是因为伴随图层移动所进行的绘图错做非常消耗时间，导致系统来不及处理FIFO中的鼠标移动数据，所以我们等FIFO为空时再进行绘图操作。

- 添加使用Shift+F2启动命令行窗口的功能，同时我们增加可以启动多个命令行窗口的功能。

- 我们实现了开启多个命令行窗口的功能，自然而然的我们就要实现关闭命令行窗口的功能。

- 增加两个新的命令start（打开一个新的命令行窗口并运行指定的应用程序）和ncst（不打开新的命令行窗口而运行指定的应用程序）。

## 第二十七天
- 继续修补小细节，实现在启动应用程序后可以关闭命令行窗口的功能。
- 现在我们可以阻止应用程序访问操作系统用的段，但是一个应用程序访问其他应用程序的段，所以我们要使用LDT（local descriptor table）。我们通过GDTR寄存器将GDT的内存地址告知CPU，而LDT的内存地址则是通过在GDT中创建LDT段来告知CPU的。
- 由于创建应用程序时所引用的a_nask.nas变大了，在应用程序中我们没有使用的函数也被包含了进去。因此我们选择将函数拆开，从而在链接阶段，只将每个应用程序必需的.obj文件链接上去，这样可以有效减小应用程序的大小。
- 但是拆开会产生过多的.obj文件，想要解决这个问题，我们可以使用“库”，通过作者提供的库管理器，我们可以将.obj打包成一个.lib文件，这样文件的数量就减少了
- 最后就是整理Makefile使其更精简整洁